// /***
//  * 
//  * Functional Requirement:
//  * 1. Atur sampling rate --> ini apa?
//  * 2. Atur durasi pengambilan data
//  * 3. Atur jumlah data yang dirata-rata
//  * 4. Atur mode upload data ke cloud (langsung kirim atau tunggu konfimasi)
//  * 
//  ***/

// #include <Arduino.h>
// #include <Ticker.h>
// #include "Utilities.h"
// // #include "Internet/InternetHandler.h"
// // #include "Internet/MqttHandler.h"
// // #include "Internet/Queue.h"

// // LoadcellDataQueue loadcellDataQueue;

// #define LOADCELL1 36
// #define LOADCELL2 39
// #define LOADCELL3 34

// int adc[3] = {0, 0, 0};
// bool startSampling = true;
// Ticker interval;
// uint32_t attempt = 1;
// float duration = 0.5;
// int averageAmount = 50;

// void samplingTask(void*);
// void adcSampling() {
//     Serial.print("Begin sampling,");
//     Serial.print(attempt++);
//     Serial.print(",");
//     startSampling = true;
// }

// void setup() {
//     Serial.begin(250000);

//     interval.attach(duration, adcSampling);
//     xTaskCreate(samplingTask, "samplingTask", 2048, NULL, 1, NULL);
// }

// void loop() {
//     if (Serial.available() > 0) {
//         String command = Serial.readString();
//         if (command.substring(0, command.indexOf(':')) == "Duration") {
//             duration = command.substring(command.indexOf(':') + 1, command.indexOf(';')).toFloat();
//             attempt = 1;
//             interval.detach();
//             delay(100);
//             interval.attach(duration, adcSampling);
//             Serial.print("Change duration to ");
//             Serial.print(duration);
//             Serial.println("s");
//         }
//     }
// }

// void samplingTask(void* pvParameters) {
//     if (startSampling == true) {
//         startSampling = false;
//         for (int j = 0; j < averageAmount; j++) {
//             adc[0] += analogRead(LOADCELL1);
//             adc[1] += analogRead(LOADCELL2);
//             adc[2] += analogRead(LOADCELL3);
//             delayMicroseconds(200);
//         }
//         Serial.print(adc[0] / 50);
//         Serial.print(",");
//         Serial.print(adc[1] / 50);
//         Serial.print(",");
//         Serial.print(adc[2] / 50);
//         Serial.println(",");
//         adc[0] = 0;
//         adc[1] = 0;
//         adc[2] = 0;
//     }
// }

// void saveToSd() {}
// void publishToMqtt() {}

#include <Arduino.h>
#include <PubSubClient.h>
#include <WiFi.h>

// void setup() {
//     Serial.begin(115200);
//     Serial.println("espidf-arduino-bareminimum");

//     WiFi.begin();
// }

// void loop() {
//     ledOnOff();
// }

volatile int interruptCounter;
uint32_t totalInterruptCounter = 0;

hw_timer_t* timer = NULL;
portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;

void IRAM_ATTR onTimer() {
    portENTER_CRITICAL_ISR(&timerMux);
    interruptCounter++;
    portEXIT_CRITICAL_ISR(&timerMux);
}

void setup() {
    Serial.begin(115200);

    timer = timerBegin(0, 80, true);
    timerAttachInterrupt(timer, &onTimer, true);
    // timerAlarmWrite(timer, 1000000, true); // 1000000 micro seconds
    timerAlarmWrite(timer, 100, true);
    timerAlarmEnable(timer);
}

void loop() {
    if (interruptCounter > 0) {
        if (totalInterruptCounter % 100 == 0) {
            Serial.print("An interrupt as occurred. Total number: ");
            Serial.print(totalInterruptCounter);
            Serial.print("; Interrupt Counter: ");
            Serial.println(interruptCounter);
        }
        portENTER_CRITICAL(&timerMux);
        interruptCounter--;
        portEXIT_CRITICAL(&timerMux);

        if (totalInterruptCounter < 2000000)
            totalInterruptCounter++;
        else
            totalInterruptCounter = 0;
    }
}